#include <glad/glad.h>
#include <GLFW/glfw3.h>
#include <vector>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>

#include <iostream>
#include <cmath>

#define STB_IMAGE_IMPLEMENTATION
#include "Headers/stb_image.h"
#include "Headers/Cloth.h"
#include "Headers/Rigid.h"
#include "Headers/Program.h"
#include "Headers/Display.h"
#include "Headers/large_vector.h"

#define WIDTH 500
#define HEIGHT 500

#define AIR_FRICTION 0.02
#define TIME_STEP 0.01

/** Executing Flow **/
int running = 1;

/** Functions **/
void processInput(GLFWwindow *window);

/** Callback functions **/
void framebuffer_size_callback(GLFWwindow *window, int width, int height);
void mouse_button_callback(GLFWwindow *window, int button, int action, int mods);
void cursor_pos_callback(GLFWwindow *window, double xpos, double ypos);

/** Global **/
// Wind
int windBlowing = 0;
int windForceScale = 15;
Vec3 windStartPos;
Vec3 windDir;
Vec3 wind;
// Cloth
Vec3 clothPos(-3, 7.5, -2);
Vec2 clothSize(4, 4); //(6, 6)
Cloth cloth(clothPos, clothSize);
// Ground
Vec3 groundPos(-5, 1.5, 0);
Vec2 groundSize(10, 10);
glm::vec4 groundColor(0.8, 0.8, 0.8, 1.0);
Ground ground(groundPos, groundSize, groundColor);
// Ball
Vec3 ballPos(0, 3, -2);
int ballRadius = 1;
glm::vec4 ballColor(0.6f, 0.5f, 0.8f, 1.0f);
Ball ball(ballPos, ballRadius, ballColor);
// Window and world
GLFWwindow *window;
Vec3 bgColor = Vec3(50.0/255, 50.0/255, 60.0/255);
Vec3 gravity(0.0, -9.8 / cloth.iterationFreq, 0.0);

int main(int argc, const char * argv[])
{
    /** Prepare for rendering **/
    // Initialize GLFW
    glfwInit();
    // Set OpenGL version number as 3.3
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    // Use the core profile
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    // MacOS is forward compatible
#ifdef __APPLE__
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
#endif
    
    /** Create a GLFW window **/
    window = glfwCreateWindow(WIDTH, HEIGHT, "Cloth Simulation", NULL, NULL);
    if (window == NULL) {
        std::cout << "Failed to create GLFW window." << std::endl;
        glfwTerminate();
        return -1;
    }
    // Set the context of this window as the main context of current thread
    glfwMakeContextCurrent(window);
    
    // Initialize GLAD : this should be done before using any openGL function
    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {
        std::cout << "Failed to initialize GLAD." << std::endl;
        glfwTerminate(); // This line isn't in the official source code, but I think that it should be added here.
        return -1;
    }
    
    /** Register callback functions **/
    // Callback functions should be registered after creating window and before initializing render loop
    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);
    glfwSetMouseButtonCallback(window, mouse_button_callback);
    glfwSetCursorPosCallback(window, cursor_pos_callback);
    
    /** Renderers **/
    ClothRender clothRender(&cloth);
    ClothSpringRender clothSpringRender(&cloth);
    GroundRender groundRender(&ground);
    BallRender ballRender(&ball);
    
    Vec3 initForce(10.0, 40.0, 20.0);
    cloth.addForce(initForce);
    
    glEnable(GL_DEPTH_TEST);
    glPointSize(3);
    
    /** Redering loop **/
    running = 1;
    while (!glfwWindowShouldClose(window))
    {
        /** Check for events **/
        processInput(window);
        
        /** Set background clolor **/
        glClearColor(bgColor.x, bgColor.y, bgColor.z, 1.0); // Set color value (R,G,B,A) - Set Status
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        
        /** -------------------------------- Simulation & Rendering -------------------------------- **/
        
        if (running) {
            for (int i = 0; i < cloth.iterationFreq; i ++) {
                cloth.computeForce(TIME_STEP, gravity); 
                cloth.computeForceDerivatives(TIME_STEP) ; // jacobian
                //cloth.integrate(AIR_FRICTION, TIME_STEP);
                cloth.implicit_integration(TIME_STEP);
                //cloth.collisionResponse(&ground, &ball);
            }
            cloth.computeNormal();
        }
        
        /** Display **/
        if (cloth.drawMode == Cloth::DRAW_LINES) {
            clothSpringRender.flush();
        } else {
            clothRender.flush();
        }
        ballRender.flush();
        groundRender.flush();
        
        /** -------------------------------- Simulation & Rendering -------------------------------- **/
        
        glfwSwapBuffers(window);
        glfwPollEvents(); // Update the status of window
    }

    glfwTerminate();
    
    return 0;
}

void framebuffer_size_callback(GLFWwindow *window, int width, int height)
{
    glViewport(0, 0, width, height);
}

void mouse_button_callback(GLFWwindow* window, int button, int action, int mods)
{
    if(button == GLFW_MOUSE_BUTTON_LEFT && action == GLFW_PRESS && running) // Start wind
    {
        windBlowing = 1;
        // Set start point of wind direction
        windStartPos.setZeroVec();
        glfwGetCursorPos(window, &windStartPos.x, &windStartPos.y);
        windStartPos.y = -windStartPos.y; // Reverse y since the screen local in the fourth quadrant
    }
    if(button == GLFW_MOUSE_BUTTON_LEFT && action == GLFW_RELEASE && running) // End wind
    {
        windBlowing = 0;
        windDir.setZeroVec();
    }
}

void cursor_pos_callback(GLFWwindow* window, double xpos, double ypos)
{
    /** Wind **/
    if (windBlowing && running) {
        windDir = Vec3(xpos, -ypos, 0) - windStartPos;
        windDir.normalize();
        wind = windDir * windForceScale;
        cloth.addForce(wind);
    }
}

void processInput(GLFWwindow *window)
{
    /** Keyboard control **/ // If key did not get pressed it will return GLFW_RELEASE
    if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) {
        glfwSetWindowShouldClose(window, true);
    }
    
    /** Set draw mode **/
    if (glfwGetKey(window, GLFW_KEY_Z) == GLFW_PRESS) {
        cloth.drawMode = Cloth::DRAW_NODES;
    }
    if (glfwGetKey(window, GLFW_KEY_X) == GLFW_PRESS) {
        cloth.drawMode = Cloth::DRAW_LINES;
    }
    if (glfwGetKey(window, GLFW_KEY_C) == GLFW_PRESS) {
        cloth.drawMode = Cloth::DRAW_FACES;
    }
    
    /** Camera control : [W] [S] [A] [D] [Q] [E] **/
    if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) {
        cam.pos.y += cam.speed;
    }
    if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) {
        cam.pos.y -= cam.speed;
    }
    if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS) {
        cam.pos.x -= cam.speed;
    }
    if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS) {
        cam.pos.x += cam.speed;
    }
    if (glfwGetKey(window, GLFW_KEY_Q) == GLFW_PRESS) {
        cam.pos.z -= cam.speed;
    }
    if (glfwGetKey(window, GLFW_KEY_E) == GLFW_PRESS) {
        cam.pos.z += cam.speed;
    }
    
    /** Pause simulation **/
    if (glfwGetKey(window, GLFW_KEY_T) == GLFW_PRESS) {
        running = 0;
        printf("Paused.\n");
    }
    if (glfwGetKey(window, GLFW_KEY_R) == GLFW_PRESS) {
        running = 1;
        printf("Running..\n");
    }
    
    /** Drop the cloth **/
    if (glfwGetKey(window, GLFW_KEY_O) == GLFW_PRESS && running) {
        cloth.unPin(cloth.pin1);
    }
    if (glfwGetKey(window, GLFW_KEY_P) == GLFW_PRESS && running) {
        cloth.unPin(cloth.pin2);
    }
    
    /** Pull cloth **/
    if (glfwGetKey(window, GLFW_KEY_UP) == GLFW_PRESS && running) {
        cloth.addForce(Vec3(0.0, 0.0, -windForceScale));
    }
    if (glfwGetKey(window, GLFW_KEY_DOWN) == GLFW_PRESS && running) {
        cloth.addForce(Vec3(0.0, 0.0, windForceScale));
    }
    if (glfwGetKey(window, GLFW_KEY_LEFT) == GLFW_PRESS && running) {
        cloth.addForce(Vec3(-windForceScale, 0.0, 0.0));
    }
    if (glfwGetKey(window, GLFW_KEY_RIGHT) == GLFW_PRESS && running) {
        cloth.addForce(Vec3(windForceScale, 0.0, 0.0));
    }
}
#include <glad/glad.h>
#include <GLFW/glfw3.h>
#include <vector>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>

#include <iostream>
#include <cmath>

#define STB_IMAGE_IMPLEMENTATION
#include "Headers/stb_image.h"
#include "Headers/Cloth.h"
#include "Headers/Rigid.h"
#include "Headers/Program.h"
#include "Headers/Display.h"
#include "Headers/large_vector.h"

using namespace std;

// ------ View parameters ------
#define WIDTH 1024
#define HEIGHT 1024
int oldX = 0, oldY = 0;
float rX = 15, rY = 0;
int state = 1;
float dist = -23;
const int GRID_SIZE = 10;
double frameTimeQP = 0;
float frameTime = 0;
int exportedFrames = 0;
// LARGE_INTEGER frequency;        // ticks per second
// LARGE_INTEGER t1, t2;           // ticks
#define AIR_FRICTION 0.02
#define TIME_STEP 5/60.0f;
// ------ Paricle & Spring parameters ------
struct Spring {
	int p1, p2;
	float rest_length;
	float Ks, Kd;
	int type;
};

vector<GLushort> indices;
vector<Spring> springs;

// �����ֲ���[-halfsize, halfsize] x[0, fullsize] �������
int numX = 20, numY = 20;
const size_t total_points = (numX + 1) * (numY + 1);
float fullsize = 4.0f;
float halfsize = fullsize / 2.0f;
glm::vec3 gravity = glm::vec3(0.0f, -0.0981f, 0.0f);
float mass = 1.f;


const int STRUCTURAL_SPRING = 0;
const int SHEAR_SPRING = 1;
const int BEND_SPRING = 2;

int spring_count = 0;
const float DEFAULT_DAMPING = -0.125f;
float	KsStruct = 0.75f, KdStruct = -0.25f;
float	KsShear = 0.75f, KdShear = -0.25f;
float	KsBend = 0.95f, KdBend = -0.25f;

vector<glm::vec3> Particle;// position
vector<glm::vec3> Velocity;// velocity
vector<glm::vec3> F;// force

// ------- Collision detection�� ��������� -------
glm::mat4 ellipsoid, inverse_ellipsoid;
int iStacks = 30;
int iSlices = 30;
float fRadius = 1;

glm::vec3 center = glm::vec3(0, 0, 0); //object space center of ellipsoid
float radius = 1;					 //object space radius of ellipsoid


// ------ Implicit Integration & Conjugate Gradient parameters------
LargeVector<glm::mat3> A;
LargeVector<glm::vec3> b;
glm::mat3 M = glm::mat3(1.0f);

vector<glm::vec3> dc_dp; //  dc/dp
vector<glm::mat3> df_dx; //  df/dp
vector<glm::mat3> df_dv; //  df/dv
LargeVector<glm::vec3> dV;

LargeVector<glm::vec3> P_;
LargeVector<glm::vec3> P_inv;
vector<float> inv_len;
vector<float> C; //for implicit integration
vector<float> C_Dot; //for implicit integration
vector<glm::vec3> deltaP2;//for implicit integration
	// conjugate parameters
const float EPS = 0.001f;
const float EPS2 = EPS * EPS;
const int i_max = 10;
// ------ Simulation parameters------
float timeStep = 10 / 60.0f;
float currentTime = 0;
double accumulator = timeStep;
int selected_index = -1;

// char info[MAX_PATH] = { 0 };

void StepPhysics(float dt);

void SolveConjugateGradientPreconditioned(LargeVector<glm::mat3> A, LargeVector<glm::vec3>& x, LargeVector<glm::vec3> b, LargeVector<glm::vec3> P, LargeVector<glm::vec3> P_inv) {
	float i = 0;

	// ��� r �ӽ�������������˵�����ǵĽ��Ѿ��ǳ��ӽ���ʵ���ˡ�
	LargeVector<glm::vec3> r = (b - A * x);

	// Ԥ��������������Ǹ���ϵͳ�����ʣ��粡̬�̶ȣ���ʹ�õ��������ܹ������������
	LargeVector<glm::vec3> d = P_inv * r;
	LargeVector<glm::vec3> q;
	float alpha_new = 0;
	float alpha = 0;
	float beta = 0;
	float delta_old = 0;
	float delta_new = dot(r, P * r);
	float delta0 = delta_new;
	while (i<i_max && delta_new > EPS2 * delta0) {
		// ���� q������ q = A * d
		q = A * d;

		// ���㲽�� alpha����ʾ�ڵ�ǰ�������� d ��Ӧ��ǰ���ĳ���
		alpha = delta_new / dot(d, q);

		// ���½� x
		x = x + alpha * d;

		// ���²в� r
		r = r - alpha * q;

		// �����µ���� delta_new
		delta_old = delta_new;
		delta_new = dot(r, r);

		// ������������ĵ���ϵ�� beta
		beta = delta_new / delta_old;

		// ������������ d
		d = r + beta * d;
		i++;
	}
}
void AddSpring(int a, int b, float ks, float kd, int type) {
	Spring spring;
	spring.p1 = a;
	spring.p2 = b;
	spring.Ks = ks;
	spring.Kd = kd;
	spring.type = type;
	glm::vec3 deltaP = Particle[a] - Particle[b];
	spring.rest_length = sqrt(glm::dot(deltaP, deltaP));
	springs.push_back(spring);
}

void initMassSpring(){
    int i = 0, j = 0, count = 0;
	int l1 = 0, l2 = 0;
	float ypos = 7.0f;
	int v = numY + 1;
	int u = numX + 1;

	indices.resize(numX * numY * 2 * 3);
	Particle.resize(total_points);
	Velocity.resize(total_points);
	F.resize(total_points);

	A.resize(total_points);
	b.resize(total_points);
	dV.resize(total_points);
	P_.resize(total_points);
	P_inv.resize(total_points);


	//fill in X
	for (j = 0; j <= numY; j++) {
		for (i = 0; i <= numX; i++) {
			Particle[count++] = glm::vec3(((float(i) / (u - 1)) * 2 - 1) * halfsize, fullsize + 1, ((float(j) / (v - 1)) * fullsize));
		}
	}

	//fill in V
	memset(&(Velocity[0].x), 0, total_points * sizeof(glm::vec3));

	//fill in indices
	GLushort* id = &indices[0];
	for (i = 0; i < numY; i++) {
		for (j = 0; j < numX; j++) {
			int i0 = i * (numX + 1) + j;
			int i1 = i0 + 1;
			int i2 = i0 + (numX + 1);
			int i3 = i2 + 1;
			if ((j + i) % 2) {
				*id++ = i0; *id++ = i2; *id++ = i1;
				*id++ = i1; *id++ = i2; *id++ = i3;
			}
			else {
				*id++ = i0; *id++ = i2; *id++ = i3;
				*id++ = i0; *id++ = i3; *id++ = i1;
			}
		}
	}

	//setup springs
	// Horizontal
	for (l1 = 0; l1 < v; l1++)	// v
		for (l2 = 0; l2 < (u - 1); l2++) {
			AddSpring((l1 * u) + l2, (l1 * u) + l2 + 1, KsStruct, KdStruct, STRUCTURAL_SPRING);
		}

	// Vertical
	for (l1 = 0; l1 < (u); l1++)
		for (l2 = 0; l2 < (v - 1); l2++) {
			AddSpring((l2 * u) + l1, ((l2 + 1) * u) + l1, KsStruct, KdStruct, STRUCTURAL_SPRING);
		}


	// Shearing Springs
	for (l1 = 0; l1 < (v - 1); l1++)
		for (l2 = 0; l2 < (u - 1); l2++) {
			AddSpring((l1 * u) + l2, ((l1 + 1) * u) + l2 + 1, KsShear, KdShear, SHEAR_SPRING);
			AddSpring(((l1 + 1) * u) + l2, (l1 * u) + l2 + 1, KsShear, KdShear, SHEAR_SPRING);
		}


	// Bend Springs
	for (l1 = 0; l1 < (v); l1++) {
		for (l2 = 0; l2 < (u - 2); l2++) {
			AddSpring((l1 * u) + l2, (l1 * u) + l2 + 2, KsBend, KdBend, BEND_SPRING);
		}
		AddSpring((l1 * u) + (u - 3), (l1 * u) + (u - 1), KsBend, KdBend, BEND_SPRING);
	}
	for (l1 = 0; l1 < (u); l1++) {
		for (l2 = 0; l2 < (v - 2); l2++) {
			AddSpring((l2 * u) + l1, ((l2 + 2) * u) + l1, KsBend, KdBend, BEND_SPRING);
		}
		AddSpring(((v - 3) * u) + l1, ((v - 1) * u) + l1, KsBend, KdBend, BEND_SPRING);
	}

	int total_springs = springs.size();
	C.resize(total_springs);
	inv_len.resize(total_springs);
	C_Dot.resize(total_springs);
	dc_dp.resize(total_springs);
	deltaP2.resize(total_springs);
	df_dx.resize(total_springs);
	df_dv.resize(total_springs);
	memset(&(C[0]), 0, total_springs * sizeof(float));
	memset(&(C_Dot[0]), 0, total_springs * sizeof(float));
	memset(&(deltaP2[0].x), 0, total_springs * sizeof(glm::vec3));

	memset(&(P_[0].x), 0, total_points * sizeof(glm::vec3));
	memset(&(P_inv[0].x), 0, total_points * sizeof(glm::vec3));

	//create a basic ellipsoid object
	ellipsoid = glm::translate(glm::mat4(1), glm::vec3(0, 2, 0));
	ellipsoid = glm::rotate(ellipsoid, 45.0f, glm::vec3(1, 0, 0));
	ellipsoid = glm::scale(ellipsoid, glm::vec3(fRadius, fRadius, fRadius / 2));
	inverse_ellipsoid = glm::inverse(ellipsoid);
}
void OnShutdown() {
	Particle.clear();
	Velocity.clear();
	F.clear();
	indices.clear();
	springs.clear();
	dc_dp.clear();
	df_dx.clear();
	df_dv.clear();
	C.clear();
	C_Dot.clear();
	deltaP2.clear();

	dV.clear();
	A.clear();

	b.clear();
	P_.clear();
	P_inv.clear();
	inv_len.clear();
}

void ComputeForces() {
	size_t i = 0;

	// �������еĵ�
	for (i = 0; i < total_points; i++) {
		// ��ʼ����Ϊ0
		F[i] = glm::vec3(0);

		// ����㲻�ڱ�Ե����������
		if (i != 0 && i != (numX))
			F[i] += gravity;

		// ���������������������ٶȳ�����
		F[i] += DEFAULT_DAMPING * Velocity[i];
	}


	// �������еĵ���
	for (i = 0; i < springs.size(); i++) {
		// ���㵯�����˵�λ�ú��ٶ�
		glm::vec3 p1 = Particle[springs[i].p1];
		glm::vec3 p2 = Particle[springs[i].p2];
		glm::vec3 v1 = Velocity[springs[i].p1];
		glm::vec3 v2 = Velocity[springs[i].p2];
		glm::vec3 deltaP = p1 - p2;
		glm::vec3 deltaV = v1 - v2;

		// ���㵯�ɳ��Ⱥ���仯��
		float dist = glm::length(deltaP);
		inv_len[i] = 1.0f / dist;// ���������õ�����ǰ�������Ч��
		// �����쳤��
		C[i] = dist - springs[i].rest_length;

		// ��λ�������������ķ���
		dc_dp[i] = deltaP / dist;

		// �ڵ��ɷ����ϵ�ͶӰ�ֱ𱻼�ȥ�ͼ��ϣ��õ����ǵ��ɵ��쳤��ѹ���ٶȡ�����ٶ�Ӱ�쵽���ɵ�������
		C_Dot[i] = glm::dot(v1, -dc_dp[i]) + glm::dot(v2, dc_dp[i]);

		// ����ʸ��������ƽ�����ں��������õ�����ǰ�������Ч��
		deltaP2[i] = glm::vec3(deltaP.x * deltaP.x, deltaP.y * deltaP.y, deltaP.z * deltaP.z);

		// ���㵯������������������������
		float leftTerm = -springs[i].Ks * (dist - springs[i].rest_length);
		float rightTerm = springs[i].Kd * (glm::dot(deltaV, deltaP) / dist);
		glm::vec3 springForce = (leftTerm + rightTerm) * glm::normalize(deltaP);

		// ������ɵ����˲��ڱ�Ե�����ϵ�����
		if (springs[i].p1 != 0 && springs[i].p1 != numX)
			F[springs[i].p1] += springForce;
		if (springs[i].p2 != 0 && springs[i].p2 != numX)
			F[springs[i].p2] -= springForce;
	}
}

void CalcForceDerivatives() {
	// �������λ�ú��ٶȵĵ���
	memset(&(df_dx[0]), 0, total_points * sizeof(glm::mat3));
	memset(&(df_dv[0]), 0, total_points * sizeof(glm::mat3));

	size_t i = 0;

	// ���׵�������ĳ�ʼ��
	glm::mat3 d2C_dp2[2][2] = { glm::mat3(1.0f),glm::mat3(1.0f),glm::mat3(1.0f),glm::mat3(1.0f) };

	// �����е��ɽ��б���������ÿһ�����ɵ�����λ�ú��ٶȵĵ���
	for (i = 0; i < springs.size(); i++) {
		// ����ÿ�����ɼ�����׵���
		// �洢���ɵ��쳤����c1
		float c1 = C[i];
		// ��������λ�õĶ��׵���
		d2C_dp2[0][0][0][0] = (-c1 * deltaP2[i].x + c1);
		d2C_dp2[0][0][1][1] = (-c1 * deltaP2[i].y + c1);
		d2C_dp2[0][0][2][2] = (-c1 * deltaP2[i].z + c1);

		d2C_dp2[0][1][0][0] = (c1 * deltaP2[i].x - c1);
		d2C_dp2[0][1][1][1] = (c1 * deltaP2[i].y - c1);
		d2C_dp2[0][1][2][2] = (c1 * deltaP2[i].z - c1);

		d2C_dp2[1][0] = d2C_dp2[0][1];
		d2C_dp2[1][1] = d2C_dp2[0][0];

		// dc_dp[i] = deltaP / dist; ���ֵ��Ӱ�쵽��������λ�ú��ٶȵĵ����ļ���
		glm::mat3 dp1 = glm::outerProduct(dc_dp[i], dc_dp[i]);
		glm::mat3 dp2 = glm::outerProduct(dc_dp[i], -dc_dp[i]);
		glm::mat3 dp3 = glm::outerProduct(-dc_dp[i], -dc_dp[i]);

		// ʹ��Hooke���ɣ����ɶ��ɣ����������Ӽ�������λ�ú��ٶȵĵ���
		// ��������λ�õ�һ�׵���
		df_dx[i] += -springs[i].Ks * (dp1 + (d2C_dp2[0][0] * C[i])) - springs[i].Kd * (d2C_dp2[0][0] * C_Dot[i]);
		df_dx[i] += -springs[i].Ks * (dp2 + (d2C_dp2[0][1] * C[i])) - springs[i].Kd * (d2C_dp2[0][1] * C_Dot[i]);
		df_dx[i] += -springs[i].Ks * (dp2 + (d2C_dp2[1][1] * C[i])) - springs[i].Kd * (d2C_dp2[1][1] * C_Dot[i]);

		// ���������ٶȵ�һ�׵���
		df_dv[i] += -springs[i].Kd * dp1;
		df_dv[i] += -springs[i].Kd * dp2;
		df_dv[i] += -springs[i].Kd * dp3;
	}
}

void IntegrateImplicit(float deltaTime) {
	float h = deltaTime;

	// ��������λ�ú��ٶȵĵ���
	CalcForceDerivatives();

	// ������
	float y = 0.0;//correction term
	size_t i = 0;
	for (i = 0; i < total_points; i++) {
		// ��������ϵͳAx = b�����ں�������ʽ���ּ���
		A[i] = M - h * (df_dv[i] + h * df_dx[i]);
		b[i] = (h * (F[i] + h * df_dx[i] * (Velocity[i] + y)));

		// ����Ԥ�������������Ż�����ϵͳ�����
		P_[i] = glm::vec3(A[i][0][0], A[i][1][1], A[i][2][2]);
		P_inv[i] = 1.0f / P_[i];// glm::vec3(1.0f/A[0][0], 1.0f/A[1][1], 1.0f/A[2][2]);
	}

	// ʹ��Ԥ���������ݶȷ��������ϵͳ���õ��ٶȱ仯��dV
	SolveConjugateGradientPreconditioned(A, dV, b, P_, P_inv);

	for (i = 0; i < total_points; i++) {
		// ʹ�õõ����ٶȱ仯��dV�����ٶȺ�λ��
		Velocity[i] += (dV[i] * deltaTime);
		Particle[i] += deltaTime * Velocity[i];

		// ������º��λ�õ�yֵС��0��ͨ����ʾ���崩�����棩����yֵ��Ϊ0�����⴩������
		if (Particle[i].y < 0) {
			Particle[i].y = 0;
		}
	}
}

void ApplyProvotDynamicInverse() {

	for (size_t i = 0; i < springs.size(); i++) {
		//check the current lengths of all springs
		glm::vec3 p1 = Particle[springs[i].p1];
		glm::vec3 p2 = Particle[springs[i].p2];
		glm::vec3 deltaP = p1 - p2;
		float dist = glm::length(deltaP);
		if (dist > (springs[i].rest_length * 1.01f)) {
			dist -= (springs[i].rest_length * 1.01f);
			dist /= 2.0f;
			deltaP = glm::normalize(deltaP);
			deltaP *= dist;
			if (springs[i].p1 == 0 || springs[i].p1 == numX) {
				Velocity[springs[i].p2] += deltaP;
			}
			else if (springs[i].p2 == 0 || springs[i].p2 == numX) {
				Velocity[springs[i].p1] -= deltaP;
			}
			else {
				Velocity[springs[i].p1] -= deltaP;
				Velocity[springs[i].p2] += deltaP;
			}
		}
	}
}
void EllipsoidCollision() {
	for (size_t i = 0; i < total_points; i++) {
		glm::vec4 X_0 = (inverse_ellipsoid * glm::vec4(Particle[i], 1));
		glm::vec3 delta0 = glm::vec3(X_0.x, X_0.y, X_0.z) - center;
		float distance = glm::length(delta0);
		if (distance < 1.0f) {
			delta0 = (radius - distance) * delta0 / distance;

			// Transform the delta back to original space
			glm::vec3 delta;
			glm::vec3 transformInv;
			transformInv = glm::vec3(ellipsoid[0].x, ellipsoid[1].x, ellipsoid[2].x);
			transformInv /= glm::dot(transformInv, transformInv);
			delta.x = glm::dot(delta0, transformInv);
			transformInv = glm::vec3(ellipsoid[0].y, ellipsoid[1].y, ellipsoid[2].y);
			transformInv /= glm::dot(transformInv, transformInv);
			delta.y = glm::dot(delta0, transformInv);
			transformInv = glm::vec3(ellipsoid[0].z, ellipsoid[1].z, ellipsoid[2].z);
			transformInv /= glm::dot(transformInv, transformInv);
			delta.z = glm::dot(delta0, transformInv);
			Particle[i] += delta;
			Velocity[i] = glm::vec3(0);
		}
	}
}


void StepPhysics(float dt) {
	ComputeForces();

	IntegrateImplicit(dt);
	EllipsoidCollision();
	ApplyProvotDynamicInverse();

}


/** Executing Flow **/
int running = 1;

/** Functions **/
void processInput(GLFWwindow *window);

/** Callback functions **/
void framebuffer_size_callback(GLFWwindow *window, int width, int height);
void mouse_button_callback(GLFWwindow *window, int button, int action, int mods);
void cursor_pos_callback(GLFWwindow *window, double xpos, double ypos);

/** Global **/
// Wind
int windBlowing = 0;
int windForceScale = 15;
Vec3 windStartPos;
Vec3 windDir;
Vec3 wind;
// Cloth
Vec3 clothPos(-3, 7.5, -2);
Vec2 clothSize(4, 4); //(6, 6)
Cloth cloth(clothPos, clothSize);
// Ground
Vec3 groundPos(-5, 1.5, 0);
Vec2 groundSize(10, 10);
glm::vec4 groundColor(0.8, 0.8, 0.8, 1.0);
Ground ground(groundPos, groundSize, groundColor);
// Ball
Vec3 ballPos(0, 3, -2);
int ballRadius = 1;
glm::vec4 ballColor(0.6f, 0.5f, 0.8f, 1.0f);
Ball ball(ballPos, ballRadius, ballColor);
// Window and world
GLFWwindow *window;
Vec3 bgColor = Vec3(50.0/255, 50.0/255, 60.0/255);


int main(int argc, const char * argv[])
{
    /** Prepare for rendering **/
    // Initialize GLFW
    glfwInit();
    // Set OpenGL version number as 3.3
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    // Use the core profile
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    // MacOS is forward compatible
#ifdef __APPLE__
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
#endif
    
    /** Create a GLFW window **/
    window = glfwCreateWindow(WIDTH, HEIGHT, "Cloth Simulation", NULL, NULL);
    if (window == NULL) {
        std::cout << "Failed to create GLFW window." << std::endl;
        glfwTerminate();
        return -1;
    }
    // Set the context of this window as the main context of current thread
    glfwMakeContextCurrent(window);
    
    // Initialize GLAD : this should be done before using any openGL function
    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {
        std::cout << "Failed to initialize GLAD." << std::endl;
        glfwTerminate(); // This line isn't in the official source code, but I think that it should be added here.
        return -1;
    }
    
    /** Register callback functions **/
    // Callback functions should be registered after creating window and before initializing render loop
    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);
    glfwSetMouseButtonCallback(window, mouse_button_callback);
    glfwSetCursorPosCallback(window, cursor_pos_callback);
    
    /** Renderers **/
    ClothRender clothRender(&cloth);
    ClothSpringRender clothSpringRender(&cloth);
    GroundRender groundRender(&ground);
    BallRender ballRender(&ball);
    
    Vec3 initForce(10.0, 40.0, 20.0);
    cloth.addForce(initForce);
    
    glEnable(GL_DEPTH_TEST);
    glPointSize(3);
    
    /** Redering loop **/
    running = 1;
    while (!glfwWindowShouldClose(window))
    {
        /** Check for events **/
        processInput(window);
        
        /** Set background clolor **/
        glClearColor(bgColor.x, bgColor.y, bgColor.z, 1.0); // Set color value (R,G,B,A) - Set Status
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        
        /** -------------------------------- Simulation & Rendering -------------------------------- **/
        
        if (running) {
            for (int i = 0; i < cloth.iterationFreq; i ++) {
                cloth.computeForce(TIME_STEP, gravity); 
                cloth.computeForceDerivatives(TIME_STEP) ; // jacobian
                //cloth.integrate(AIR_FRICTION, TIME_STEP);
                cloth.implicit_integration(TIME_STEP);
                //cloth.collisionResponse(&ground, &ball);
            }
            cloth.computeNormal();
        }
        
        /** Display **/
        if (cloth.drawMode == Cloth::DRAW_LINES) {
            clothSpringRender.flush();
        } else {
            clothRender.flush();
        }
        ballRender.flush();
        groundRender.flush();
        
        /** -------------------------------- Simulation & Rendering -------------------------------- **/
        
        glfwSwapBuffers(window);
        glfwPollEvents(); // Update the status of window
    }

    glfwTerminate();
    
    return 0;
}

void framebuffer_size_callback(GLFWwindow *window, int width, int height)
{
    glViewport(0, 0, width, height);
}

void mouse_button_callback(GLFWwindow* window, int button, int action, int mods)
{
    if(button == GLFW_MOUSE_BUTTON_LEFT && action == GLFW_PRESS && running) // Start wind
    {
        windBlowing = 1;
        // Set start point of wind direction
        windStartPos.setZeroVec();
        glfwGetCursorPos(window, &windStartPos.x, &windStartPos.y);
        windStartPos.y = -windStartPos.y; // Reverse y since the screen local in the fourth quadrant
    }
    if(button == GLFW_MOUSE_BUTTON_LEFT && action == GLFW_RELEASE && running) // End wind
    {
        windBlowing = 0;
        windDir.setZeroVec();
    }
}

void cursor_pos_callback(GLFWwindow* window, double xpos, double ypos)
{
    /** Wind **/
    if (windBlowing && running) {
        windDir = Vec3(xpos, -ypos, 0) - windStartPos;
        windDir.normalize();
        wind = windDir * windForceScale;
        cloth.addForce(wind);
    }
}

void processInput(GLFWwindow *window)
{
    /** Keyboard control **/ // If key did not get pressed it will return GLFW_RELEASE
    if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) {
        glfwSetWindowShouldClose(window, true);
    }
    
    /** Set draw mode **/
    if (glfwGetKey(window, GLFW_KEY_Z) == GLFW_PRESS) {
        cloth.drawMode = Cloth::DRAW_NODES;
    }
    if (glfwGetKey(window, GLFW_KEY_X) == GLFW_PRESS) {
        cloth.drawMode = Cloth::DRAW_LINES;
    }
    if (glfwGetKey(window, GLFW_KEY_C) == GLFW_PRESS) {
        cloth.drawMode = Cloth::DRAW_FACES;
    }
    
    /** Camera control : [W] [S] [A] [D] [Q] [E] **/
    if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) {
        cam.pos.y += cam.speed;
    }
    if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) {
        cam.pos.y -= cam.speed;
    }
    if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS) {
        cam.pos.x -= cam.speed;
    }
    if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS) {
        cam.pos.x += cam.speed;
    }
    if (glfwGetKey(window, GLFW_KEY_Q) == GLFW_PRESS) {
        cam.pos.z -= cam.speed;
    }
    if (glfwGetKey(window, GLFW_KEY_E) == GLFW_PRESS) {
        cam.pos.z += cam.speed;
    }
    
    /** Pause simulation **/
    if (glfwGetKey(window, GLFW_KEY_T) == GLFW_PRESS) {
        running = 0;
        printf("Paused.\n");
    }
    if (glfwGetKey(window, GLFW_KEY_R) == GLFW_PRESS) {
        running = 1;
        printf("Running..\n");
    }
    
    /** Drop the cloth **/
    if (glfwGetKey(window, GLFW_KEY_O) == GLFW_PRESS && running) {
        cloth.unPin(cloth.pin1);
    }
    if (glfwGetKey(window, GLFW_KEY_P) == GLFW_PRESS && running) {
        cloth.unPin(cloth.pin2);
    }
    
    /** Pull cloth **/
    if (glfwGetKey(window, GLFW_KEY_UP) == GLFW_PRESS && running) {
        cloth.addForce(Vec3(0.0, 0.0, -windForceScale));
    }
    if (glfwGetKey(window, GLFW_KEY_DOWN) == GLFW_PRESS && running) {
        cloth.addForce(Vec3(0.0, 0.0, windForceScale));
    }
    if (glfwGetKey(window, GLFW_KEY_LEFT) == GLFW_PRESS && running) {
        cloth.addForce(Vec3(-windForceScale, 0.0, 0.0));
    }
    if (glfwGetKey(window, GLFW_KEY_RIGHT) == GLFW_PRESS && running) {
        cloth.addForce(Vec3(windForceScale, 0.0, 0.0));
    }
}
